
#include "rose.h"
#include "dependency.h"
#include "ds.hpp"
#include "gcd_banerjee.hpp"
#include "CodeGen_Cycle_Shrink.hpp"
#include "new_loop_normalization.hpp"
#include "cycle_shrinking.hpp"
#include "CodeGen_Affinekernal_Interface.hpp"
#include "Dependence_Testing_Interface.hpp"
#include "readWrie.h"
#include "extShrinking.hpp"
#include "affinec.hpp"
#include <iostream>
#include <set>
#include <vector>
#include <iterator>
#include <algorithm>
#include <stdarg.h>
#include <getopt.h>
using namespace std;
using namespace SageInterface;
using namespace SageBuilder;
int Total_Phi=0;
char DependencyExists='n';
int noOfNestedLoops=0;
std::string op;
std::string rel_op;
int b_val;
char VariableDependenceDist='n';
struct ReferencePair *RefPair=NULL;
struct DDV *DDVvector=NULL;
Phi_Values* lambda_var=NULL;
ofstream outputfile;
ifstream inputfile;
class visitorTraversal : public AstSimpleProcessing
{
public:
    virtual void visit(SgNode* n);
};
loop_data* head_loop=NULL;
loop* intersect_RAW=NULL;
loop* intersect_WAW=NULL;
loop* intersect_RAW_shrinking=NULL;
loop* head=NULL;
/*void abc(SgNode* for_loop)
{ vector<SgNode*> reads;
   vector<SgNode*> writes;
   SgForStatement* forLoop=isSgForStatement(for_loop);
    SgBasicBlock* loopBody = isSgBasicBlock(forLoop->get_loop_body());
    if(loopBody!=NULL)
    {    vector<SgNode*>:: iterator itr;
       //  Rose_STL_Container<SgStatement*> forLoops = loopBody->get_statements();
        //  for(Rose_STL_Container<SgStatement*>::iterator iter = forLoops.begin(); iter!= forLoops.end(); iter++ )
         {
          // SgScopeStatement* scope=(*iter)->get_scope();


          SageInterface::collectReadWriteRefs(forLoop, reads, writes);
           for (itr=reads.begin();itr!=reads.end();itr++)
           {
              if(isSgBinaryOp(*itr)!=NULL)
                {
                 cout<<" read "<<(*itr)->unparseToString()<<endl;
                 }
         }

   }
}}*/
void ref_function1(SgNode* for_loop,SgFunctionDefinition *defn )
{
    SgForStatement* forLoop=isSgForStatement(for_loop);
    SgBasicBlock* loopBody = isSgBasicBlock(forLoop->get_loop_body());
    Rose_STL_Container<SgStatement*> forLoops = loopBody->get_statements();
    for(Rose_STL_Container<SgStatement*>::iterator iter = forLoops.begin(); iter!= forLoops.end(); iter++ )
    {

        cout<<" statements are "<< (*iter)->unparseToString()<<"\n";
    }
}

int main(int argc, char * argv[])
{
/* cout<<"abc";
  int q=argc;
  cout<<argc<<endl;
   while(q)
   {
     cout<<"arg "<<argv[--q]<<endl;
     
   }*/
    char* outfile;
    char* infile, *fileName;
     SgProject *project = frontend (argc, argv);
    SgFunctionDeclaration* func = SageInterface::findMain(project);
     SgSourceFile* file = isSgSourceFile((*project)[0]);
     cout<<"file = "<<file->getFileName();
    const char* file_name=(file->getFileName()).c_str();
    ifstream fin;
    fin.open(file_name,ios::in);
    char* dependence_test,*shrinking,*verbosity_no;
    dependence_test = (char*)malloc(sizeof(char)*20);
    shrinking = (char*)malloc(sizeof(char)*20);
    infile = (char*)malloc(sizeof(char)*50);
    fileName = (char*)malloc(sizeof(char)*50);
    strcpy(infile,"input/");
    outfile = (char*)malloc(sizeof(char)*50);
    strcpy(outfile,"output/");
    strcpy(dependence_test, "gcd");
    strcpy(shrinking, "simple");
   /* static struct option long_options[] = {
        {"fileName", required_argument,       0,  'f' },
        {"depTest",    required_argument, 0,  'd' },
        {"cycleShrink",   required_argument, 0,  'c' },
        {0,           0,                 0,  0   }
        };
        int long_index =0, opt;
    while ((opt = getopt_long(argc, argv,"f:d:c:", 
                   long_options, &long_index )) != -1) {
        switch (opt) {
            
             case 'f' : 
                   strcpy(fileName, optarg);
                   strcat(infile, optarg);
                   strcat(outfile, optarg);
                   strcat(outfile, "u");
                   break;
             case 'd' : 
                   strcpy(dependence_test, optarg);
                   break;
             case 'c' : 
                   strcpy(shrinking, optarg);
                   break;
            default: 
                    fprintf(stderr, "Usage: %s [--fileName=name.c] [--depTest=gcd/banerjee] [--cycleShrink=simple/extShrinking1/extShrinking2]\n", argv[0]);
                }}
              
                
    if(strcmp(fileName,"")==0)
    {
        strcat(infile, "input.c");
        strcat(outfile, "input.cu");
    }
    if(strcmp(dependence_test,"")==0)
            strcpy(dependence_test,"gcd");
    if(strcmp(shrinking,"")==0)
            strcpy(shrinking,"simple");
    */
    inputfile.open(file_name, ifstream::in);
    string file_name_output=strcat(strdup(file_name),"u");
  //  cout<<"output file "<<file_name_output<<endl;
    outputfile.open(strcat(strdup(file_name),"u"), ios::out );
    
   
    string line;
    ifstream myfile ("config.txt");
     int time=0;
   if (myfile.is_open())
   {
    while (! myfile.eof() )
    {
    getline (myfile,line);
     char *cstr = new char[line.length() + 1];
      strcpy(cstr, line.c_str());
     
      if(time==0){ dependence_test=cstr;}
      if(time==1) {shrinking=cstr;}
     time++;
    
  }}
    cout<<"shrinking "<<shrinking<<endl;
    cout<<"dep "<<dependence_test<<endl;
    vector<SgNode*> readRefs;
    vector<SgNode*> writeRefs;
    vector<SgNode*>:: iterator itr;
    string newFilename_output = "new_source_file.c";
   // outputfile.open (newFilename_output.c_str(), ios::out );
   
    /*visitorTraversal ae;
    ae.traverseInputFiles(project,preorder);
     display1(head_loop);*/
    set<string> var;
   // set<string> :: iterator i;

    SgFunctionDefinition *defn = func->get_definition();
  
    set<SgInitializedName*> readNames, writeNames;
    if (!SageInterface::collectReadWriteVariables(func,readNames,writeNames))
    {
        ROSE_ASSERT(false);
    }
    set<SgInitializedName*>::iterator iter;
    for (iter=readNames.begin(); iter!=readNames.end(); iter++)
    {
        // cout<<"read variable:"<<(*iter)->unparseToString()<<endl;
        var.insert((*iter)->unparseToString());
    }

// ROSE_ASSERT(writeNames.size() ==4);

    for (iter=writeNames.begin(); iter!=writeNames.end(); iter++)
    {
        //   cout<<"written variable:"<<(*iter)->unparseToString()<<endl;
        var.insert((*iter)->unparseToString());
    }
    //for(i=var.begin();i!=var.end();i++)
    // cout<<" "<<*i ;
    Rose_STL_Container<SgNode*> forLoops = NodeQuery::querySubTree(defn,V_SgForStatement);
   for(Rose_STL_Container<SgNode*>::iterator iter = forLoops.begin(); iter!= forLoops.end(); iter++ )
    {
        cout<<"------------------loop normalization ---------------------------"<<endl;
        loop_normalization(*iter,var);
       // cout<<"after normalization "<<(*iter)->unparseToString();

    }
    cout<<"-----------done with normalization----------"<<endl;
    for(Rose_STL_Container<SgNode*>::iterator iter = forLoops.begin(); iter!= forLoops.end(); iter++ )
    {
        // printf ("Found a SgForStatement \n");
        // abc(*iter);


        // printf ("Found a SgForStatement \n");


        ref_function(*iter,defn);
       // ref_function1(*iter,defn);

    }


    cout<<"display head"<<endl;
    display(head);

    calculate_intersection_RAW(head);
    cout<<"after intersection  RAW"<<"\n";
    display(intersect_RAW);
    calculate_intersection_WAW(head);
    cout<<"after intersection  WAW"<<"\n";
    display(intersect_WAW);
    calculate_intersection_RAW_for_srinking(head);
    cout<<"after intersection  RAW for cycle shrinking"<<"\n";
    display(intersect_RAW_shrinking);
    int loop_num=0;
       int i=1,k,f;
         char c;
         int endline ;
         int startLine;
        int m=0;
        int count1=0;
    for(Rose_STL_Container<SgNode*>::iterator iter = forLoops.begin(); iter!= forLoops.end(); iter++ )
    {
       
       loop* temp=intersect_RAW;
        loop* temp1=intersect_RAW_shrinking;
        while(temp1->loop_number!=loop_num)
            temp1=temp1->next;
       

        while(temp->loop_number!=loop_num)
            temp=temp->next;
          SgForStatement* node=isSgForStatement(*iter);
//if(node) DeleteSgTree(node);
        Sg_File_Info * startInfo = node->get_startOfConstruct();
        Sg_File_Info * endInfo = node->get_endOfConstruct();
        if(startInfo && endInfo)
        {
            startLine = startInfo->get_line();
            endline = endInfo->get_line();
            int startCol= startInfo->get_col();
            int endCol=endInfo->get_col();
// if at least one line is referenced then we can't delete it
//for(int i = startLine; i <= endline ; i++) {
           // cout<<"Start = "<<startLine<<"end = "<<endline<<endl;



            i=1;

         //   cout<<"i= "<<i<<endl;
//fprintf(out, "start ");
            if(count1==0 && m==0)
            {
                while(!fin.eof() && i<startLine  )
                {

                    fin.get(c);
                  //  cout<<"i = "<<i<<"startLine = "<<startLine<<"c= "<<c<<endl;
                    if(c=='\n')
                    {
                        i++;
                        outputfile<<endl;
                    }
                    else
                        outputfile<<c;
                }
                count1++;
                 m++;
                    Dependence_Testing_Interface(dependence_test, temp,*iter,loop_num);
                    CycleShrinking( shrinking, temp1,*iter,loop_num, var);
                   //Simple_Loops_Code_Gen(temp,*iter,m,var);
                  cuda_kernel_declaration_AFFINE(shrinking,*iter,"i");
                  cuda_kernel_call_AFFINE(shrinking,*iter,"i",loop_num);
                  cuda_kernel_definition_AFFINE(shrinking,"i",*iter,defn,loop_num);
            }
         //   cout<<"for loop is "<<(*iter)->unparseToString()<<endl;
            else if(m!=0 && count1!=0)
            {
                i=f;

                while(i<=k && !fin.eof())
                {
                 //   cout<<"k = "<<k<<"c = "<<c<< "i= "<<i<<endl;
                    fin.get(c);
                    if(c=='\n')
                    {
                        i++;
                        if(i>k) break;
                    }
                }
                while(!fin.eof() && i<startLine)
                {

                    fin.get(c);
                 //   cout<<"i in inner loop "<<i<<"c= "<<c<<endl;
                    if(c=='\n')
                    {
                        i++;
                        outputfile<<endl;
                    }
                    else outputfile<<c;
                }
                Dependence_Testing_Interface(dependence_test, temp,*iter,loop_num);
         CycleShrinking( shrinking, temp1,*iter,loop_num, var);
        //Simple_Loops_Code_Gen(temp,*iter,m,var);
         cuda_kernel_declaration_AFFINE(shrinking,*iter,"i");
         cuda_kernel_call_AFFINE(shrinking,*iter,"i",loop_num);
         cuda_kernel_definition_AFFINE(shrinking,"i",*iter,defn,loop_num);
            }


        }

        k=endline;
        f=startLine;
    }
    i=f;
    while(i<=k && !fin.eof())
    {
       // cout<<"k = "<<k<<"c = "<<c<< "i= "<<i<<endl;
        fin.get(c);
        if(c=='\n')
        {
            i++;
            if(i>k) break;
        }
    }
    while(!fin.eof() )
    {

        fin.get(c);
      //  cout<<"i in inner loop "<<i<<"c= "<<c<<endl;
        if(c=='\n')
        {
            i++;
            outputfile<<endl;
        }
        else outputfile<<c;
    }


    loop_num=0;
   /* for(Rose_STL_Container<SgNode*>::iterator iter = forLoops.begin(); iter!= forLoops.end(); iter++ )
    {
        loop* temp=intersect_RAW_shrinking;
        while(temp->loop_number!=m)
            temp=temp->next;
        cout<<"--------in loop ------------"<<endl;
        Simple_Loops_Code_Gen(temp,*iter,m,var);
        extCS_VariableDistance_Lambda(temp,*iter,m,var);
        cout<<"Total_Phi "<<Total_Phi<<endl;
// temp=temp->next;
        Total_Phi=0;
        m++;
    }*/
 //   m=0;

    /*    for(Rose_STL_Container<SgNode*>::iterator iter = forLoops.begin(); iter!= forLoops.end(); iter++ )
    {
       loop* temp=intersect_RAW_shrinking;
         while(temp->loop_number!=m)
          temp=temp->next;
        cout<<"--------in loop next ------------"<<endl;
    extCS_VariableDistance_Lambda(temp,*iter,m,var);
     // temp=temp->next;
    m++;
    }*/
    return backend(project);
}
