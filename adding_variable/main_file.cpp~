
#include "rose.h"
#include "dependency.h"
#include "ds.hpp"
#include "gcd_banerjee.hpp"
#include "readWrie.h"
#include <iostream>
#include <set>
#include <vector>
#include <iterator>
#include <algorithm>

using namespace std;
using namespace SageInterface;
using namespace SageBuilder;

class visitorTraversal : public AstSimpleProcessing
{
    public:
       virtual void visit(SgNode* n);
};
loop_data* head_loop=NULL;
loop* intersect_RAW=NULL;
loop* intersect_WAW=NULL;
loop* head=NULL;
void abc(SgNode* for_loop)
{
   SgForStatement* forLoop=isSgForStatement(for_loop);
    SgBasicBlock* loopBody = isSgBasicBlock(forLoop->get_loop_body());
    if(loopBody!=NULL)
    {    vector<SgNode*>:: iterator itr;
         Rose_STL_Container<SgStatement*> forLoops = loopBody->get_statements();
          for(Rose_STL_Container<SgStatement*>::iterator iter = forLoops.begin(); iter!= forLoops.end(); iter++ )
         {
           cout<<(*iter)->unparseToString()<<"\n"; 
         }
   }
}
int main(int argc, char * argv[])
{
     vector<SgNode*> readRefs;
     vector<SgNode*> writeRefs;
     vector<SgNode*>:: iterator itr;
    SgProject *project = frontend (argc, argv);
    SgFunctionDeclaration* func = SageInterface::findMain(project);
    visitorTraversal ae;
    ae.traverseInputFiles(project,preorder);
     display1(head_loop);
    SgFunctionDefinition *defn = func->get_definition();
    Rose_STL_Container<SgNode*> forLoops = NodeQuery::querySubTree(defn,V_SgForStatement);
    for(Rose_STL_Container<SgNode*>::iterator iter = forLoops.begin(); iter!= forLoops.end(); iter++ )
    {
        // printf ("Found a SgForStatement \n");
        // abc(*iter);
        
       ref_function(*iter,defn);//

/*         for(iter1 = pntrArrRefList.begin(); iter1 != pntrArrRefList.end(); ++iter1) 
         {

          if(a!=NULL)
          { cout<<"abc"<<"\n";  
            if(isAssignmentStatement(a,NULL,NULL))
              cout<<"found statement"<<"\n";
          }
          
          
     
         }*/
   
    }

    
display(head);
calculate_intersection_RAW(head);
cout<<"after intersection  RAW"<<"\n";
display(intersect_RAW);
calculate_intersection_WAW(head);
cout<<"after intersection  WAW"<<"\n";
display(intersect_WAW);
int m=0;
 for(Rose_STL_Container<SgNode*>::iterator iter = forLoops.begin(); iter!= forLoops.end(); iter++ )
{

int k= GCD_Test(intersect_RAW,*iter);
if(k==1)
 cout<<"GCD dep may exists"<<endl;
else
cout<<"no dependency"<<endl;
m++;
}
 return backend(project);
 }
