#ifndef DATASET
	#define _NTHREAD 512
	#define _NBLOCK 65535
#endif

#include<cuda.h>
#include<time.h>
# include <stdlib.h>
# include <stdio.h>
# include <math.h>
# include <time.h>

# include "ball_monte_carlo.h"

/******************************************************************************/

double ball01_monomial_integral ( int e[3] )

/******************************************************************************/
/*
  Purpose:

    BALL01_MONOMIAL_INTEGRAL returns monomial integrals in the unit ball.

  Discussion:

    The integration region is 

      X^2 + Y^2 + Z^2 <= 1.

    The monomial is F(X,Y,Z) = X^E(1) * Y^E(2) * Z^E(3).

  Licensing:

    This code is distributed under the GNU LGPL license. 

  Modified:

    02 January 2014

  Author:

    John Burkardt

  Reference:

    Philip Davis, Philip Rabinowitz,
    Methods of Numerical Integration,
    Second Edition,
    Academic Press, 1984, page 263.

  Parameters:

    Input, int E[3], the exponents of X, Y and Z in the 
    monomial.  Each exponent must be nonnegative.

    Output, double BALL01_MONOMIAL_INTEGRAL, the integral.
*/
{
  int i;
  double integral;
  const double r = 1.0;
  double s;

  if ( e[0] < 0 || e[1] < 0 || e[2] < 0 )
  {
    fprintf ( stderr, "\n" );
    fprintf ( stderr, "BALL01_MONOMIAL_INTEGRAL - Fatal error!\n" );
    fprintf ( stderr, "  All exponents must be nonnegative.\n" );
    fprintf ( stderr, "  E[0] = %d\n", e[0] );
    fprintf ( stderr, "  E[1] = %d\n", e[1] );
    fprintf ( stderr, "  E[2] = %d\n", e[2] );
    exit ( 1 );
  }

__global__ void _AFFINE_KERNEL_0(int* ,int ,int ,int ,int );

#define MIN(a,b) (((a)<(b))?(a):(b))
#include<cuda.h>

	#ifdef DATASET
		char* outfile = (char*)malloc(sizeof(char)*(strlen(readfile)+50));
		strcpy(outfile, readfile);
		strcat(outfile, ".data");
		FILE* fp;
		fp = fopen(outfile, "a");
	#endif

	#ifdef TIME
		struct timespec start_0, end_0, mid_start_0, mid_end_0;
		double runTime_0, pre_time_0, post_time_0, computeTime_0;
	#endif
	int _SZ_e_0 = 3;

	#ifdef TIME
		clock_gettime(CLOCK_MONOTONIC, &start_0);
	#endif

	// ----------Allocating memory to Kernel Variable and copying them on device----------
	int *_DEV_e_0;
	cudaMalloc((void**) &_DEV_e_0,sizeof(int) *_SZ_e_0);
	cudaMemcpy(_DEV_e_0,e,sizeof(int) *_SZ_e_0, cudaMemcpyHostToDevice);
	int _NUM_THREADS_0 = 3;
	float _NUM_BLOCKS_0=1;
	int _NUM_TILE_0=1;
	dim3 _THREADS_0(512);
	dim3 _BLOCKS_0(1);
	if(_NUM_THREADS_0 < _NTHREAD)
	{
		_THREADS_0.x=_NUM_THREADS_0;
	}
	else {
		 _THREADS_0.x=_NTHREAD;
		_NUM_BLOCKS_0=(_NUM_THREADS_0 % _NTHREAD == 0)?(_NUM_THREADS_0/_NTHREAD):((_NUM_THREADS_0/_NTHREAD)+1);
		if(_NUM_BLOCKS_0<_NBLOCK)
			_BLOCKS_0.x=_NUM_BLOCKS_0;
		else {
			_BLOCKS_0.x=_NBLOCK;
			int temp_0=_NUM_BLOCKS_0;
			_NUM_TILE_0=(temp_0 % _NBLOCK == 0)?(_NUM_BLOCKS_0/_NBLOCK):((_NUM_BLOCKS_0/_NBLOCK)+1);
		}
	}
	int ID_1_0, ID_2_0, START[1];

	#ifdef TIME
		clock_gettime(CLOCK_MONOTONIC, &mid_start_0);
	#endif

	int _CUDA_TILE_0;
	int Phi_0[1]={3};
	int loopUpperLimits_0[1]={2};
	for(ID_1_0=1;ID_1_0<=2/3+1;ID_1_0++)
	{
		for(ID_2_0=0;ID_2_0<1;ID_2_0++)
		{
			if(Phi_0[ID_2_0]>=0)
				START[ID_2_0]=(ID_1_0-1)*Phi_0[ID_2_0];
			else
				START[ID_2_0]=loopUpperLimits_0[ID_2_0]+(ID_1_0-1)*Phi_0[ID_2_0];
		}
	for(_CUDA_TILE_0=0;_CUDA_TILE_0<_NUM_TILE_0;_CUDA_TILE_0++)
	{
		_AFFINE_KERNEL_0<<<_BLOCKS_0,_THREADS_0>>>( _DEV_e_0, _SZ_e_0,START[0], MIN(START[0]+3, 2), _CUDA_TILE_0);
			cudaDeviceSynchronize();
	}
	}

	#ifdef TIME
		clock_gettime(CLOCK_MONOTONIC, &mid_end_0);
	#endif
	cudaMemcpy(e, _DEV_e_0,sizeof(int) *_SZ_e_0, cudaMemcpyDeviceToHost);
	cudaFree(_DEV_e_0);

	#ifdef TIME
		clock_gettime(CLOCK_MONOTONIC, &end_0);
		pre_time_0 = (double) ((((&mid_start_0)->tv_sec * 1000000000) + (&mid_start_0)->tv_nsec) - (((&start_0)->tv_sec * 1000000000) + (&start_0)->tv_nsec)) / 1000000000;
		post_time_0 = (double) ((((&end_0)->tv_sec * 1000000000) + (&end_0)->tv_nsec) - (((&mid_end_0)->tv_sec * 1000000000) + (&mid_end_0)->tv_nsec)) / 1000000000;
		computeTime_0 = (double) ((((&mid_end_0)->tv_sec * 1000000000) + (&mid_end_0)->tv_nsec) - (((&mid_start_0)->tv_sec * 1000000000) + (&mid_start_0)->tv_nsec)) / 1000000000;
		runTime_0 = (double) ((((&end_0)->tv_sec * 1000000000) + (&end_0)->tv_nsec) - (((&start_0)->tv_sec * 1000000000) + (&start_0)->tv_nsec)) / 1000000000;
	#endif

	#ifdef DATASET
		fprintf(fp,"%%d,%%d,%%d,%%d,%%d,%%.14f,%%.14f,%%.14f,%%.14f,%%d\n",N,_NTHREAD*_NBLOCK,_THREADS_0.x,_BLOCKS_0.x,data,pre_time_0,computeTime_0,post_time_0,runTime_0,_CUDA_TILE_0);
		fclose(fp);
		fclose(f);
	#else
	#ifdef TIME
		printf("Runtime:%%f\n",runTime_0);
	#endif
	#endif
/*
  The surface integral is now adjusted to give the volume integral.
*/
  s = e[0] + e[1] + e[2] + 3;

  integral = integral * pow ( r, s  ) / ( double ) ( s );

  return integral;
}
/******************************************************************************/

double *ball01_sample ( int n, int *seed )

/******************************************************************************/
/*
  Purpose:

    BALL01_SAMPLE uniformly samples points from the unit ball.

  Licensing:

    This code is distributed under the GNU LGPL license. 

  Modified:

    02 January 2014

  Author:

    John Burkardt

  Reference:

    Russell Cheng,
    Random Variate Generation,
    in Handbook of Simulation,
    edited by Jerry Banks,
    Wiley, 1998, pages 168.

    Reuven Rubinstein,
    Monte Carlo Optimization, Simulation, and Sensitivity 
    of Queueing Networks,
    Krieger, 1992,
    ISBN: 0894647644,
    LC: QA298.R79.

  Parameters:

    Input, int N, the number of points.

    Input/output, int *SEED, a seed for the random 
    number generator.

    Output, double X[3*N], the points.
*/
{
  const double exponent = 1.0 / 3.0;
  int i;
  int j;
  double norm;
  double r;
  double *x;

  x = r8mat_normal_01_new ( 3, n, seed );

__global__ void _AFFINE_KERNEL_1(int ,int ,int );

#define MIN(a,b) (((a)<(b))?(a):(b))
#include<cuda.h>

	#ifdef DATASET
		char* outfile = (char*)malloc(sizeof(char)*(strlen(readfile)+50));
		strcpy(outfile, readfile);
		strcat(outfile, ".data");
		FILE* fp;
		fp = fopen(outfile, "a");
	#endif

	#ifdef TIME
		struct timespec start_1, end_1, mid_start_1, mid_end_1;
		double runTime_1, pre_time_1, post_time_1, computeTime_1;
	#endif

	#ifdef TIME
		clock_gettime(CLOCK_MONOTONIC, &start_1);
	#endif

	// ----------Allocating memory to Kernel Variable and copying them on device----------
	int _NUM_THREADS_1 = 1;
	float _NUM_BLOCKS_1=1;
	int _NUM_TILE_1=1;
	dim3 _THREADS_1(512);
	dim3 _BLOCKS_1(1);
	if(_NUM_THREADS_1 < _NTHREAD)
	else {
	int ID_1_1, ID_2_1, START[0];

	#ifdef TIME
		clock_gettime(CLOCK_MONOTONIC, &mid_start_1);
	#endif

	int _CUDA_TILE_1;
	int Phi_1[1]={0};
	int loopUpperLimits_1[1]={2};
	for(ID_1_1=1;ID_1_1<=2/0+1;ID_1_1++)
	{
		for(ID_2_1=0;ID_2_1<1;ID_2_1++)
		{
			if(Phi_1[ID_2_1]>=0)
				START[ID_2_1]=(ID_1_1-1)*Phi_1[ID_2_1];
			else
				START[ID_2_1]=loopUpperLimits_1[ID_2_1]+(ID_1_1-1)*Phi_1[ID_2_1];
		}
	for(_CUDA_TILE_1=0;_CUDA_TILE_1<_NUM_TILE_1;_CUDA_TILE_1++)
	{
		_AFFINE_KERNEL_1<<<_BLOCKS_1,_THREADS_1>>>(START[0], MIN(START[0]+0, 2), _CUDA_TILE_1);
			cudaDeviceSynchronize();
	}
	}

	#ifdef TIME
		clock_gettime(CLOCK_MONOTONIC, &mid_end_1);
	#endif

	#ifdef TIME
		clock_gettime(CLOCK_MONOTONIC, &end_1);
		pre_time_1 = (double) ((((&mid_start_1)->tv_sec * 1000000000) + (&mid_start_1)->tv_nsec) - (((&start_1)->tv_sec * 1000000000) + (&start_1)->tv_nsec)) / 1000000000;
		post_time_1 = (double) ((((&end_1)->tv_sec * 1000000000) + (&end_1)->tv_nsec) - (((&mid_end_1)->tv_sec * 1000000000) + (&mid_end_1)->tv_nsec)) / 1000000000;
		computeTime_1 = (double) ((((&mid_end_1)->tv_sec * 1000000000) + (&mid_end_1)->tv_nsec) - (((&mid_start_1)->tv_sec * 1000000000) + (&mid_start_1)->tv_nsec)) / 1000000000;
		runTime_1 = (double) ((((&end_1)->tv_sec * 1000000000) + (&end_1)->tv_nsec) - (((&start_1)->tv_sec * 1000000000) + (&start_1)->tv_nsec)) / 1000000000;
	#endif

	#ifdef DATASET
		fprintf(fp,"%%d,%%d,%%d,%%d,%%d,%%.14f,%%.14f,%%.14f,%%.14f,%%d\n",N,_NTHREAD*_NBLOCK,_THREADS_1.x,_BLOCKS_1.x,data,pre_time_1,computeTime_1,post_time_1,runTime_1,_CUDA_TILE_1);
		fclose(fp);
		fclose(f);
	#else
	#ifdef TIME
		printf("Runtime:%%f\n",runTime_1);
	#endif
	#endif
/*
  Now compute a value to map the point ON the sphere INTO the sphere.
*/
    r = r8_uniform_01 ( seed );

   
  
  return x;
}
/******************************************************************************/

double ball01_volume ( )

/******************************************************************************/
/*
  Purpose:

    BALL01_VOLUME returns the volume of the unit ball.

  Licensing:

    This code is distributed under the GNU LGPL license. 

  Modified:

    02 January 2014

  Author:

    John Burkardt

  Parameters:

    Output, double BALL01_VOLUME, the volume of the unit ball.
*/
{
  const double r = 1.0;
  const double r8_pi = 3.141592653589793;
  double volume;

  volume = 4.0 * r8_pi * pow ( r, 3 ) / 3.0;

  return volume;
}
/******************************************************************************/

double *monomial_value ( int m, int n, int e[], double x[] )

/******************************************************************************/
/*
  Purpose:

    MONOMIAL_VALUE evaluates a monomial.

  Discussion:

    This routine evaluates a monomial of the form

      product ( 1 <= i <= m ) x(i)^e(i)

    where the exponents are nonnegative integers.  Note that
    if the combination 0^0 is encountered, it should be treated
    as 1.

  Licensing:

    This code is distributed under the GNU LGPL license. 

  Modified:

    08 May 2014

  Author:

    John Burkardt

  Parameters:

    Input, int M, the spatial dimension.

    Input, int N, the number of points at which the
    monomial is to be evaluated.

    Input, int E[M], the exponents.

    Input, double X[M*N], the point coordinates.

    Output, double MONOMIAL_VALUE[N], the value of the monomial.
*/
{
  int i;
  int j;
  double *v;

  v = ( double * ) malloc ( n * sizeof ( double ) );

__global__ void _AFFINE_KERNEL_2(int ,int ,int );


	#ifdef DATASET
		char* outfile = (char*)malloc(sizeof(char)*(strlen(readfile)+50));
		strcpy(outfile, readfile);
		strcat(outfile, ".data");
		FILE* fp;
		fp = fopen(outfile, "a");
	#endif

	#ifdef TIME
		struct timespec start_2, end_2, mid_start_2, mid_end_2;
		double runTime_2, pre_time_2, post_time_2, computeTime_2;
	#endif

	#ifdef TIME
		clock_gettime(CLOCK_MONOTONIC, &start_2);
	#endif

	// ----------Allocating memory to Kernel Variable and copying them on device----------
	int _NUM_THREADS_2= 1;
	float _NUM_BLOCKS_2=1;
	int _NUM_TILE_2=1;
	dim3 _THREADS_2(512);
	dim3 _BLOCKS_2(1);
	if(_NUM_THREADS_2 < _NTHREAD)
	else {

	#ifdef TIME
		clock_gettime(CLOCK_MONOTONIC, &mid_start_2);
	#endif

	int _CUDA_TILE_2;
	for(_CUDA_TILE_2=0;_CUDA_TILE_2<_NUM_TILE_2;_CUDA_TILE_2++)
	{
		_AFFINE_KERNEL_2<<<_BLOCKS_2,_THREADS_2>>>(0,9, _CUDA_TILE_2);
		cudaDeviceSynchronize();
	}

	#ifdef TIME
		clock_gettime(CLOCK_MONOTONIC, &mid_end_2);
	#endif

	#ifdef TIME
		clock_gettime(CLOCK_MONOTONIC, &end_2);

		pre_time_2 = (double) ((((&mid_start_2)->tv_sec * 1000000000) + (&mid_start_2)->tv_nsec) - (((&start_2)->tv_sec * 1000000000) + (&start_2)->tv_nsec)) / 1000000000;
		post_time_2 = (double) ((((&end_2)->tv_sec * 1000000000) + (&end_2)->tv_nsec) - (((&mid_end_2)->tv_sec * 1000000000) + (&mid_end_2)->tv_nsec)) / 1000000000;
		computeTime_2 = (double) ((((&mid_end_2)->tv_sec * 1000000000) + (&mid_end_2)->tv_nsec) - (((&mid_start_2)->tv_sec * 1000000000) + (&mid_start_2)->tv_nsec)) / 1000000000;
		runTime_2 = (double) ((((&end_2)->tv_sec * 1000000000) + (&end_2)->tv_nsec) - (((&start_2)->tv_sec * 1000000000) + (&start_2)->tv_nsec)) / 1000000000;
	#endif

	#ifdef DATASET
		fprintf(fp,"%%d,%%d,%%d,%%d,%%d,%%.14f,%%.14f,%%.14f,%%.14f,%%d\n",N,_NTHREAD*_NBLOCK,_THREADS_2.x,_BLOCKS_2.x,data,pre_time_2,computeTime_2,post_time_2,runTime_2,_CUDA_TILE_2);
		fclose(fp);
		fclose(f);
	#else
	#ifdef TIME
		printf("Runtime:%%f\n",runTime_2);
	#endif
	#endif

  

  return v;
}
/******************************************************************************/
double r8_uniform_01 ( int *seed )

/******************************************************************************/
/*
  Purpose:

    R8_UNIFORM_01 returns a pseudorandom R8 scaled to [0,1].

  Discussion:

    This routine implements the recursion

      seed = 16807 * seed mod ( 2^31 - 1 )
      r8_uniform_01 = seed / ( 2^31 - 1 )

    The integer arithmetic never requires more than 32 bits,
    including a sign bit.

    If the initial seed is 12345, then the first three computations are

      Input     Output      R8_UNIFORM_01
      SEED      SEED

         12345   207482415  0.096616
     207482415  1790989824  0.833995
    1790989824  2035175616  0.947702

  Licensing:

    This code is distributed under the GNU LGPL license.

  Modified:

    11 August 2004

  Author:

    John Burkardt

  Reference:

    Paul Bratley, Bennett Fox, Linus Schrage,
    A Guide to Simulation,
    Springer Verlag, pages 201-202, 1983.

    Pierre L'Ecuyer,
    Random Number Generation,
    in Handbook of Simulation
    edited by Jerry Banks,
    Wiley Interscience, page 95, 1998.

    Bennett Fox,
    Algorithm 647:
    Implementation and Relative Efficiency of Quasirandom
    Sequence Generators,
    ACM Transactions on Mathematical Software,
    Volume 12, Number 4, pages 362-376, 1986.

    P A Lewis, A S Goodman, J M Miller,
    A Pseudo-Random Number Generator for the System/360,
    IBM Systems Journal,
    Volume 8, pages 136-143, 1969.

  Parameters:

    Input/output, int *SEED, the "seed" value.  Normally, this
    value should not be 0.  On output, SEED has been updated.

    Output, double R8_UNIFORM_01, a new pseudorandom variate, strictly between
    0 and 1.
*/
{
  int i4_huge = 2147483647;
  int k;
  double r;

  k = *seed / 127773;

  *seed = 16807 * ( *seed - k * 127773 ) - k * 2836;

  if ( *seed < 0 )
  {
    *seed = *seed + i4_huge;
  }

  r = ( ( double ) ( *seed ) ) * 4.656612875E-10;

  return r;
}
/******************************************************************************/

double *r8mat_normal_01_new ( int m, int n, int *seed )

/******************************************************************************/
/*
  Purpose:

    R8MAT_NORMAL_01_NEW returns a unit pseudonormal R8MAT.

  Licensing:

    This code is distributed under the GNU LGPL license. 

  Modified:

    03 October 2005

  Author:

    John Burkardt

  Reference:

    Paul Bratley, Bennett Fox, Linus Schrage,
    A Guide to Simulation,
    Springer Verlag, pages 201-202, 1983.

    Bennett Fox,
    Algorithm 647:
    Implementation and Relative Efficiency of Quasirandom
    Sequence Generators,
    ACM Transactions on Mathematical Software,
    Volume 12, Number 4, pages 362-376, 1986.

    Peter Lewis, Allen Goodman, James Miller,
    A Pseudo-Random Number Generator for the System/360,
    IBM Systems Journal,
    Volume 8, pages 136-143, 1969.

  Parameters:

    Input, int M, N, the number of rows and columns in the array.

    Input/output, int *SEED, the "seed" value, which should NOT be 0.
    On output, SEED has been updated.

    Output, double R8MAT_NORMAL_01_NEW[M*N], the array of pseudonormal values.
*/
{
  double *r;

  r = r8vec_normal_01_new ( m * n, seed );

  return r;
}
/******************************************************************************/
double *r8vec_normal_01_new ( int n, int *seed )

/******************************************************************************/
/*
  Purpose:

    R8VEC_NORMAL_01_NEW returns a unit pseudonormal R8VEC.

  Discussion:

    The standard normal probability distribution function (PDF) has
    mean 0 and standard deviation 1.

  Licensing:

    This code is distributed under the GNU LGPL license.

  Modified:

    06 August 2013

  Author:

    John Burkardt

  Parameters:

    Input, int N, the number of values desired.

    Input/output, int *SEED, a seed for the random number generator.

    Output, double R8VEC_NORMAL_01_NEW[N], a sample of the standard normal PDF.

  Local parameters:

    Local, double R[N+1], is used to store some uniform random values.
    Its dimension is N+1, but really it is only needed to be the
    smallest even number greater than or equal to N.

    Local, int X_LO, X_HI, records the range of entries of
    X that we need to compute.
*/
{
  int i;
  int m;
  const double pi = 3.141592653589793;
  double *r;
  double *x;
  int x_hi;
  int x_lo;

  x = ( double * ) malloc ( n * sizeof ( double ) );
/*
  Record the range of X we need to fill in.
*/
  x_lo = 1;
  x_hi = n;
/*
  If we need just one new value, do that here to avoid null arrays.
*/
  if ( x_hi - x_lo + 1 == 1 )
  {
    r = r8vec_uniform_01_new ( 2, seed );

    x[x_hi-1] = sqrt ( - 2.0 * log ( r[0] ) ) * cos ( 2.0 * pi * r[1] );

    free ( r );
  }
/*
  If we require an even number of values, that's easy.
*/
  else if ( ( x_hi - x_lo + 1 ) % 2 == 0 )
  {
    m = ( x_hi - x_lo + 1 ) / 2;

    r = r8vec_uniform_01_new ( 2*m, seed );

   
  }
/*
  If we require an odd number of values, we generate an even number,
  and handle the last pair specially, storing one in X(N).
*/
  else
  {
    x_hi = x_hi - 1;

    m = ( x_hi - x_lo + 1 ) / 2 + 1;

    r = r8vec_uniform_01_new ( 2*m, seed );

    

    i = 2*m - 2;

    x[x_lo+i-1] = sqrt ( - 2.0 * log ( r[i] ) ) * cos ( 2.0 * pi * r[i+1] );

    free ( r );
  }

  return x;
}
/******************************************************************************/


/******************************************************************************/

double *r8vec_uniform_01_new ( int n, int *seed )

/******************************************************************************/
/*
  Purpose:

    R8VEC_UNIFORM_01_NEW returns a unit pseudorandom R8VEC.

  Discussion:

    This routine implements the recursion

      seed = 16807 * seed mod ( 2^31 - 1 )
      unif = seed / ( 2^31 - 1 )

    The integer arithmetic never requires more than 32 bits,
    including a sign bit.

  Licensing:

    This code is distributed under the GNU LGPL license.

  Modified:

    19 August 2004

  Author:

    John Burkardt

  Reference:

    Paul Bratley, Bennett Fox, Linus Schrage,
    A Guide to Simulation,
    Second Edition,
    Springer, 1987,
    ISBN: 0387964673,
    LC: QA76.9.C65.B73.

    Bennett Fox,
    Algorithm 647:
    Implementation and Relative Efficiency of Quasirandom
    Sequence Generators,
    ACM Transactions on Mathematical Software,
    Volume 12, Number 4, December 1986, pages 362-376.

    Pierre L'Ecuyer,
    Random Number Generation,
    in Handbook of Simulation,
    edited by Jerry Banks,
    Wiley, 1998,
    ISBN: 0471134031,
    LC: T57.62.H37.

    Peter Lewis, Allen Goodman, James Miller,
    A Pseudo-Random Number Generator for the System/360,
    IBM Systems Journal,
    Volume 8, Number 2, 1969, pages 136-143.

  Parameters:

    Input, int N, the number of entries in the vector.

    Input/output, int *SEED, a seed for the random number generator.

    Output, double R8VEC_UNIFORM_01_NEW[N], the vector of pseudorandom values.
*/
{
  int i;
  int i4_huge = 2147483647;
  int k;
  double *r;

  if ( *seed == 0 )
  {
    fprintf ( stderr, "\n" );
    fprintf ( stderr, "R8VEC_UNIFORM_01_NEW - Fatal error!\n" );
    fprintf ( stderr, "  Input value of SEED = 0.\n" );
    exit ( 1 );
  }

  r = ( double *) malloc ( n * sizeof ( double ) );

__global__ void _AFFINE_KERNEL_3(int ,int ,int );


	#ifdef DATASET
		char* outfile = (char*)malloc(sizeof(char)*(strlen(readfile)+50));
		strcpy(outfile, readfile);
		strcat(outfile, ".data");
		FILE* fp;
		fp = fopen(outfile, "a");
	#endif

	#ifdef TIME
		struct timespec start_3, end_3, mid_start_3, mid_end_3;
		double runTime_3, pre_time_3, post_time_3, computeTime_3;
	#endif

	#ifdef TIME
		clock_gettime(CLOCK_MONOTONIC, &start_3);
	#endif

	// ----------Allocating memory to Kernel Variable and copying them on device----------
	int _NUM_THREADS_3= 1;
	float _NUM_BLOCKS_3=1;
	int _NUM_TILE_3=1;
	dim3 _THREADS_3(512);
	dim3 _BLOCKS_3(1);
	if(_NUM_THREADS_3 < _NTHREAD)
	else {

	#ifdef TIME
		clock_gettime(CLOCK_MONOTONIC, &mid_start_3);
	#endif

	int _CUDA_TILE_3;
	for(_CUDA_TILE_3=0;_CUDA_TILE_3<_NUM_TILE_3;_CUDA_TILE_3++)
	{
		_AFFINE_KERNEL_3<<<_BLOCKS_3,_THREADS_3>>>(0,9, _CUDA_TILE_3);
		cudaDeviceSynchronize();
	}

	#ifdef TIME
		clock_gettime(CLOCK_MONOTONIC, &mid_end_3);
	#endif

	#ifdef TIME
		clock_gettime(CLOCK_MONOTONIC, &end_3);

		pre_time_3 = (double) ((((&mid_start_3)->tv_sec * 1000000000) + (&mid_start_3)->tv_nsec) - (((&start_3)->tv_sec * 1000000000) + (&start_3)->tv_nsec)) / 1000000000;
		post_time_3 = (double) ((((&end_3)->tv_sec * 1000000000) + (&end_3)->tv_nsec) - (((&mid_end_3)->tv_sec * 1000000000) + (&mid_end_3)->tv_nsec)) / 1000000000;
		computeTime_3 = (double) ((((&mid_end_3)->tv_sec * 1000000000) + (&mid_end_3)->tv_nsec) - (((&mid_start_3)->tv_sec * 1000000000) + (&mid_start_3)->tv_nsec)) / 1000000000;
		runTime_3 = (double) ((((&end_3)->tv_sec * 1000000000) + (&end_3)->tv_nsec) - (((&start_3)->tv_sec * 1000000000) + (&start_3)->tv_nsec)) / 1000000000;
	#endif

	#ifdef DATASET
		fprintf(fp,"%%d,%%d,%%d,%%d,%%d,%%.14f,%%.14f,%%.14f,%%.14f,%%d\n",N,_NTHREAD*_NBLOCK,_THREADS_3.x,_BLOCKS_3.x,data,pre_time_3,computeTime_3,post_time_3,runTime_3,_CUDA_TILE_3);
		fclose(fp);
		fclose(f);
	#else
	#ifdef TIME
		printf("Runtime:%%f\n",runTime_3);
	#endif
	#endif

  return r;
}
/******************************************************************************/

void timestamp ( )

/******************************************************************************/
/*
  Purpose:

    TIMESTAMP prints the current YMDHMS date as a time stamp.

  Example:

    31 May 2001 09:45:54 AM

  Licensing:

    This code is distributed under the GNU LGPL license.

  Modified:

    24 September 2003

  Author:

    John Burkardt

  Parameters:

    None
*/
{
# define TIME_SIZE 40

  static char time_buffer[TIME_SIZE];
  const struct tm *tm;
  size_t len;
  time_t now;

  now = time ( NULL );
  tm = localtime ( &now );

  len = strftime ( time_buffer, TIME_SIZE, "%d %B %Y %I:%M:%S %p", tm );

  fprintf ( stdout, "%s\n", time_buffer );

  return;
# undef TIME_SIZE
}




__global__ void _AFFINE_KERNEL_0(int* e,int  _SZ_e_0,int CUDA_L_i,int CUDA_U_i,int _CUDA_TILE)
{
	int i = gridDim.x*blockDim.x*_CUDA_TILE + blockDim.x*blockIdx.x + threadIdx.x;
	if((CUDA_L_i<=i)&&(i<=CUDA_U_i)){
e[1+i] = e[1+i+3];
}}



__global__ void _AFFINE_KERNEL_1(int CUDA_L_i,int CUDA_U_i,int _CUDA_TILE)
{
	int i = gridDim.x*blockDim.x*_CUDA_TILE + blockDim.x*blockIdx.x + threadIdx.x;
	if((CUDA_L_i<=i)&&(i<=CUDA_U_i)){
x[1+i+3] =(x[1+i+3] / norm);
}}



__global__ void _AFFINE_KERNEL_2(int CUDA_L_i,int CUDA_U_i,int _CUDA_TILE)
{
	int i = gridDim.x*blockDim.x*_CUDA_TILE + blockDim.x*blockIdx.x + threadIdx.x;
	if((CUDA_L_i<=i)&&(i<=CUDA_U_i)){
v[1+i] = 1.0;
}}



__global__ void _AFFINE_KERNEL_3(int CUDA_L_i,int CUDA_U_i,int _CUDA_TILE)
{
	int i = gridDim.x*blockDim.x*_CUDA_TILE + blockDim.x*blockIdx.x + threadIdx.x;
	if((CUDA_L_i<=i)&&(i<=CUDA_U_i)){
r[1+i] =((double )4) * 4.656612875E-10;
}}


