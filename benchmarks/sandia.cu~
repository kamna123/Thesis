#ifndef DATASET
	#define _NTHREAD 512
	#define _NBLOCK 65535
#endif

#include<cuda.h>
#include<time.h>
# include <stdlib.h>
# include <stdio.h>
# include <string.h>
# include <math.h>
# include <time.h>

# include "sandia_rules.h"

/******************************************************************************/

void binary_vector_next ( int n, int bvec[] )

/******************************************************************************/
/*
  Purpose:

    BINARY_VECTOR_NEXT generates the next binary vector.

  Discussion:

    A binary vector is a vector whose entries are 0 or 1.

    The user inputs an initial zero vector to start.  The program returns
    the "next" vector.

    The vectors are produced in the order:

    ( 0, 0, 0, ..., 0 )
    ( 1, 0, 0, ..., 0 ) 
    ( 0, 1, 0, ..., 0 )
    ( 1, 1, 0, ..., 0 )
    ( 0, 0, 1, ..., 0 )
    ( 1, 0, 1, ..., 0 )
               ...
    ( 1, 1, 1, ..., 1)

    and the "next" vector after (1,1,...,1) is (0,0,...,0).  That is,
    we allow wrap around.

  Example:

    N = 3

    Input      Output
    -----      ------
    0 0 0  =>  1 0 0
    1 0 0  =>  0 1 0
    0 1 0  =>  1 1 0
    1 1 0  =>  0 0 1
    0 0 1  =>  1 0 1
    1 0 1  =>  0 1 1
    0 1 1  =>  1 1 1
    1 1 1  =>  0 0 0

  Licensing:

    This code is distributed under the GNU LGPL license. 

  Modified:

    04 September 2009

  Author:

    John Burkardt

  Parameters:

    Input, int N, the dimension of the vectors.

    Input/output, int BVEC[N], on output, the successor 
    to the input vector.
*/
{
  int i;

__global__ void _AFFINE_KERNEL_0(int* ,int ,int ,int ,int );

#define MIN(a,b) (((a)<(b))?(a):(b))
#include<cuda.h>

	#ifdef DATASET
		char* outfile = (char*)malloc(sizeof(char)*(strlen(readfile)+50));
		strcpy(outfile, readfile);
		strcat(outfile, ".data");
		FILE* fp;
		fp = fopen(outfile, "a");
	#endif

	#ifdef TIME
		struct timespec start_0, end_0, mid_start_0, mid_end_0;
		double runTime_0, pre_time_0, post_time_0, computeTime_0;
	#endif
	int _SZ_bvec_0 = 1;

	#ifdef TIME
		clock_gettime(CLOCK_MONOTONIC, &start_0);
	#endif

	// ----------Allocating memory to Kernel Variable and copying them on device----------
	int *_DEV_bvec_0;
	cudaMalloc((void**) &_DEV_bvec_0,sizeof(int) *_SZ_bvec_0);
	cudaMemcpy(_DEV_bvec_0,bvec,sizeof(int) *_SZ_bvec_0, cudaMemcpyHostToDevice);
	int _NUM_THREADS_0 = 1;
	float _NUM_BLOCKS_0=1;
	int _NUM_TILE_0=1;
	dim3 _THREADS_0(512);
	dim3 _BLOCKS_0(1);
	if(_NUM_THREADS_0 < _NTHREAD)
	{
		_THREADS_0.x=_NUM_THREADS_0;
	}
	else {
		 _THREADS_0.x=_NTHREAD;
		_NUM_BLOCKS_0=(_NUM_THREADS_0 % _NTHREAD == 0)?(_NUM_THREADS_0/_NTHREAD):((_NUM_THREADS_0/_NTHREAD)+1);
		if(_NUM_BLOCKS_0<_NBLOCK)
			_BLOCKS_0.x=_NUM_BLOCKS_0;
		else {
			_BLOCKS_0.x=_NBLOCK;
			int temp_0=_NUM_BLOCKS_0;
			_NUM_TILE_0=(temp_0 % _NBLOCK == 0)?(_NUM_BLOCKS_0/_NBLOCK):((_NUM_BLOCKS_0/_NBLOCK)+1);
		}
	}
	int ID_1_0, ID_2_0, START[1];

	#ifdef TIME
		clock_gettime(CLOCK_MONOTONIC, &mid_start_0);
	#endif

	int _CUDA_TILE_0;
	int Phi_0[1]={0};
	int loopUpperLimits_0[1]={9};
	for(ID_1_0=1;ID_1_0<=9/0+1;ID_1_0++)
	{
		for(ID_2_0=0;ID_2_0<1;ID_2_0++)
		{
			if(Phi_0[ID_2_0]>=0)
				START[ID_2_0]=(ID_1_0-1)*Phi_0[ID_2_0];
			else
				START[ID_2_0]=loopUpperLimits_0[ID_2_0]+(ID_1_0-1)*Phi_0[ID_2_0];
		}
	for(_CUDA_TILE_0=0;_CUDA_TILE_0<_NUM_TILE_0;_CUDA_TILE_0++)
	{
		_AFFINE_KERNEL_0<<<_BLOCKS_0,_THREADS_0>>>( _DEV_bvec_0, _SZ_bvec_0,START[0], MIN(START[0]+0, 9), _CUDA_TILE_0);
			cudaDeviceSynchronize();
	}
	}

	#ifdef TIME
		clock_gettime(CLOCK_MONOTONIC, &mid_end_0);
	#endif
	cudaMemcpy(bvec, _DEV_bvec_0,sizeof(int) *_SZ_bvec_0, cudaMemcpyDeviceToHost);
	cudaFree(_DEV_bvec_0);

	#ifdef TIME
		clock_gettime(CLOCK_MONOTONIC, &end_0);
		pre_time_0 = (double) ((((&mid_start_0)->tv_sec * 1000000000) + (&mid_start_0)->tv_nsec) - (((&start_0)->tv_sec * 1000000000) + (&start_0)->tv_nsec)) / 1000000000;
		post_time_0 = (double) ((((&end_0)->tv_sec * 1000000000) + (&end_0)->tv_nsec) - (((&mid_end_0)->tv_sec * 1000000000) + (&mid_end_0)->tv_nsec)) / 1000000000;
		computeTime_0 = (double) ((((&mid_end_0)->tv_sec * 1000000000) + (&mid_end_0)->tv_nsec) - (((&mid_start_0)->tv_sec * 1000000000) + (&mid_start_0)->tv_nsec)) / 1000000000;
		runTime_0 = (double) ((((&end_0)->tv_sec * 1000000000) + (&end_0)->tv_nsec) - (((&start_0)->tv_sec * 1000000000) + (&start_0)->tv_nsec)) / 1000000000;
	#endif

	#ifdef DATASET
		fprintf(fp,"%%d,%%d,%%d,%%d,%%d,%%.14f,%%.14f,%%.14f,%%.14f,%%d\n",N,_NTHREAD*_NBLOCK,_THREADS_0.x,_BLOCKS_0.x,data,pre_time_0,computeTime_0,post_time_0,runTime_0,_CUDA_TILE_0);
		fclose(fp);
		fclose(f);
	#else
	#ifdef TIME
		printf("Runtime:%%f\n",runTime_0);
	#endif
	#endif
  return;
}
/******************************************************************************/
void chebyshev1_compute ( int order, double x[], double w[] )

/******************************************************************************/
/*
  Purpose:

    CHEBYSHEV1_COMPUTE computes a Chebyshev type 1 quadrature rule.

  Discussion:

    The integration interval is [ -1, 1 ].

    The weight function is w(x) = 1.0 / sqrt ( 1 - x^2 ).

    The integral to approximate:

      Integral ( -1 <= X <= 1 ) F(X) / sqrt ( 1 - x^2 ) dX

    The quadrature rule:

      Sum ( 1 <= I <= ORDER ) W(I) * F ( X(I) )

  Licensing:

    This code is distributed under the GNU LGPL license. 

  Modified:

    16 November 2009

  Author:

    John Burkardt

  Reference:

    Philip Davis, Philip Rabinowitz,
    Methods of Numerical Integration,
    Second Edition,
    Dover, 2007,
    ISBN: 0486453391,
    LC: QA299.3.D28.

  Parameters:

    Input, int ORDER, the order of the rule.
    1 <= ORDER.

    Output, double X[ORDER], the abscissas.

    Output, double W[ORDER], the weights.
*/
{
  int i;
  double pi = 3.141592653589793;

  if ( order < 1 )
  {
    printf ( "\n" );
    printf ( "CHEBYSHEV1_COMPUTE - Fatal error!\n" );
    printf ( "  Illegal value of ORDER = %d\n", order );
    exit ( 1 );
  }

__global__ void _AFFINE_KERNEL_1(double* ,int ,int ,int ,int );


	#ifdef DATASET
		char* outfile = (char*)malloc(sizeof(char)*(strlen(readfile)+50));
		strcpy(outfile, readfile);
		strcat(outfile, ".data");
		FILE* fp;
		fp = fopen(outfile, "a");
	#endif

	#ifdef TIME
		struct timespec start_1, end_1, mid_start_1, mid_end_1;
		double runTime_1, pre_time_1, post_time_1, computeTime_1;
	#endif
	double _SZ_w_1 = 1;

	#ifdef TIME
		clock_gettime(CLOCK_MONOTONIC, &start_1);
	#endif

	// ----------Allocating memory to Kernel Variable and copying them on device----------
	double *_DEV_w_1;
	cudaMalloc((void**) &_DEV_w_1,sizeof(double) *_SZ_w_1);
	cudaMemcpy(_DEV_w_1,w,sizeof(double)*_SZ_w_1, cudaMemcpyHostToDevice);
	int _NUM_THREADS_1= 1;
	float _NUM_BLOCKS_1=1;
	int _NUM_TILE_1=1;
	dim3 _THREADS_1(512);
	dim3 _BLOCKS_1(1);
	if(_NUM_THREADS_1 < _NTHREAD)
	{
		_THREADS_1.x=_NUM_THREADS_1;
	}
	else {
		 _THREADS_1.x=_NTHREAD;
		_NUM_BLOCKS_1=(_NUM_THREADS_1 % _NTHREAD == 0)?(_NUM_THREADS_1/_NTHREAD):((_NUM_THREADS_1/_NTHREAD)+1);
		if(_NUM_BLOCKS_1<_NBLOCK)
			_BLOCKS_1.x=_NUM_BLOCKS_1;
		else {
			_BLOCKS_1.x=_NBLOCK;
			int temp_1=_NUM_BLOCKS_1;
			_NUM_TILE_1=(temp_1 % _NBLOCK == 0)?(_NUM_BLOCKS_1/_NBLOCK):((_NUM_BLOCKS_1/_NBLOCK)+1);
		}
	}

	#ifdef TIME
		clock_gettime(CLOCK_MONOTONIC, &mid_start_1);
	#endif

	int _CUDA_TILE_1;
	for(_CUDA_TILE_1=0;_CUDA_TILE_1<_NUM_TILE_1;_CUDA_TILE_1++)
	{
		_AFFINE_KERNEL_1<<<_BLOCKS_1,_THREADS_1>>>( _DEV_w_1, _SZ_w_1,0,9, _CUDA_TILE_1);
		cudaDeviceSynchronize();
	}

	#ifdef TIME
		clock_gettime(CLOCK_MONOTONIC, &mid_end_1);
	#endif
	cudaMemcpy(w, _DEV_w_1,sizeof(double) *_SZ_w_1, cudaMemcpyDeviceToHost);
	cudaFree(_DEV_w_1);

	#ifdef TIME
		clock_gettime(CLOCK_MONOTONIC, &end_1);

		pre_time_1 = (double) ((((&mid_start_1)->tv_sec * 1000000000) + (&mid_start_1)->tv_nsec) - (((&start_1)->tv_sec * 1000000000) + (&start_1)->tv_nsec)) / 1000000000;
		post_time_1 = (double) ((((&end_1)->tv_sec * 1000000000) + (&end_1)->tv_nsec) - (((&mid_end_1)->tv_sec * 1000000000) + (&mid_end_1)->tv_nsec)) / 1000000000;
		computeTime_1 = (double) ((((&mid_end_1)->tv_sec * 1000000000) + (&mid_end_1)->tv_nsec) - (((&mid_start_1)->tv_sec * 1000000000) + (&mid_start_1)->tv_nsec)) / 1000000000;
		runTime_1 = (double) ((((&end_1)->tv_sec * 1000000000) + (&end_1)->tv_nsec) - (((&start_1)->tv_sec * 1000000000) + (&start_1)->tv_nsec)) / 1000000000;
	#endif

	#ifdef DATASET
		fprintf(fp,"%%d,%%d,%%d,%%d,%%d,%%.14f,%%.14f,%%.14f,%%.14f,%%d\n",N,_NTHREAD*_NBLOCK,_THREADS_1.x,_BLOCKS_1.x,data,pre_time_1,computeTime_1,post_time_1,runTime_1,_CUDA_TILE_1);
		fclose(fp);
		fclose(f);
	#else
	#ifdef TIME
		printf("Runtime:%%f\n",runTime_1);
	#endif
	#endif
__global__ void _AFFINE_KERNEL_2(double* ,int ,int ,int ,int );


	#ifdef DATASET
		char* outfile = (char*)malloc(sizeof(char)*(strlen(readfile)+50));
		strcpy(outfile, readfile);
		strcat(outfile, ".data");
		FILE* fp;
		fp = fopen(outfile, "a");
	#endif

	#ifdef TIME
		struct timespec start_2, end_2, mid_start_2, mid_end_2;
		double runTime_2, pre_time_2, post_time_2, computeTime_2;
	#endif
	double _SZ_x_2 = 1;

	#ifdef TIME
		clock_gettime(CLOCK_MONOTONIC, &start_2);
	#endif

	// ----------Allocating memory to Kernel Variable and copying them on device----------
	double *_DEV_x_2;
	cudaMalloc((void**) &_DEV_x_2,sizeof(double) *_SZ_x_2);
	cudaMemcpy(_DEV_x_2,x,sizeof(double)*_SZ_x_2, cudaMemcpyHostToDevice);
	int _NUM_THREADS_2= 1;
	float _NUM_BLOCKS_2=1;
	int _NUM_TILE_2=1;
	dim3 _THREADS_2(512);
	dim3 _BLOCKS_2(1);
	if(_NUM_THREADS_2 < _NTHREAD)
	{
		_THREADS_2.x=_NUM_THREADS_2;
	}
	else {
		 _THREADS_2.x=_NTHREAD;
		_NUM_BLOCKS_2=(_NUM_THREADS_2 % _NTHREAD == 0)?(_NUM_THREADS_2/_NTHREAD):((_NUM_THREADS_2/_NTHREAD)+1);
		if(_NUM_BLOCKS_2<_NBLOCK)
			_BLOCKS_2.x=_NUM_BLOCKS_2;
		else {
			_BLOCKS_2.x=_NBLOCK;
			int temp_2=_NUM_BLOCKS_2;
			_NUM_TILE_2=(temp_2 % _NBLOCK == 0)?(_NUM_BLOCKS_2/_NBLOCK):((_NUM_BLOCKS_2/_NBLOCK)+1);
		}
	}

	#ifdef TIME
		clock_gettime(CLOCK_MONOTONIC, &mid_start_2);
	#endif

	int _CUDA_TILE_2;
	for(_CUDA_TILE_2=0;_CUDA_TILE_2<_NUM_TILE_2;_CUDA_TILE_2++)
	{
		_AFFINE_KERNEL_2<<<_BLOCKS_2,_THREADS_2>>>( _DEV_x_2, _SZ_x_2,0,9, _CUDA_TILE_2);
		cudaDeviceSynchronize();
	}

	#ifdef TIME
		clock_gettime(CLOCK_MONOTONIC, &mid_end_2);
	#endif
	cudaMemcpy(x, _DEV_x_2,sizeof(double) *_SZ_x_2, cudaMemcpyDeviceToHost);
	cudaFree(_DEV_x_2);

	#ifdef TIME
		clock_gettime(CLOCK_MONOTONIC, &end_2);

		pre_time_2 = (double) ((((&mid_start_2)->tv_sec * 1000000000) + (&mid_start_2)->tv_nsec) - (((&start_2)->tv_sec * 1000000000) + (&start_2)->tv_nsec)) / 1000000000;
		post_time_2 = (double) ((((&end_2)->tv_sec * 1000000000) + (&end_2)->tv_nsec) - (((&mid_end_2)->tv_sec * 1000000000) + (&mid_end_2)->tv_nsec)) / 1000000000;
		computeTime_2 = (double) ((((&mid_end_2)->tv_sec * 1000000000) + (&mid_end_2)->tv_nsec) - (((&mid_start_2)->tv_sec * 1000000000) + (&mid_start_2)->tv_nsec)) / 1000000000;
		runTime_2 = (double) ((((&end_2)->tv_sec * 1000000000) + (&end_2)->tv_nsec) - (((&start_2)->tv_sec * 1000000000) + (&start_2)->tv_nsec)) / 1000000000;
	#endif

	#ifdef DATASET
		fprintf(fp,"%%d,%%d,%%d,%%d,%%d,%%.14f,%%.14f,%%.14f,%%.14f,%%d\n",N,_NTHREAD*_NBLOCK,_THREADS_2.x,_BLOCKS_2.x,data,pre_time_2,computeTime_2,post_time_2,runTime_2,_CUDA_TILE_2);
		fclose(fp);
		fclose(f);
	#else
	#ifdef TIME
		printf("Runtime:%%f\n",runTime_2);
	#endif
	#endif
  if ( ( order % 2 ) == 1 )
  {
    x[(order-1)/2] = 0.0;
  }

  return;
}
/******************************************************************************/

void chebyshev1_compute_np ( int order, int np, double p[], double x[], 
  double w[] )

/******************************************************************************/
/*
  Purpose:

    CHEBYSHEV1_COMPUTE_NP computes a Chebyshev type 1 quadrature rule.

  Discussion:

    The integration interval is [ -1, 1 ].

    The weight function is w(x) = 1.0 / sqrt ( 1 - x^2 ).

    The integral to approximate:

      Integral ( -1 <= X <= 1 ) F(X) / sqrt ( 1 - x^2 ) dX

    The quadrature rule:

      Sum ( 1 <= I <= ORDER ) W(I) * F ( X(I) )

  Licensing:

    This code is distributed under the GNU LGPL license. 

  Modified:

    16 November 2009

  Author:

    John Burkardt

  Reference:

    Philip Davis, Philip Rabinowitz,
    Methods of Numerical Integration,
    Second Edition,
    Dover, 2007,
    ISBN: 0486453391,
    LC: QA299.3.D28.

  Parameters:

    Input, int ORDER, the order of the rule.
    1 <= ORDER.

    Input, int NP, the number of parameters.

    Input, double P[NP], parameters which are not needed by this function.

    Output, double X[ORDER], the abscissas.

    Output, double W[ORDER], the weights.
*/
{
  chebyshev1_compute ( order, x, w );

  return;
}
/******************************************************************************/
void chebyshev1_compute_points ( int order, double x[] )

/******************************************************************************/
/*
  Purpose:

    CHEBYSHEV1_COMPUTE_POINTS computes Chebyshev type 1 quadrature points.

  Licensing:

    This code is distributed under the GNU LGPL license. 

  Modified:

    16 November 2009

  Author:

    John Burkardt

  Reference:

    Philip Davis, Philip Rabinowitz,
    Methods of Numerical Integration,
    Second Edition,
    Dover, 2007,
    ISBN: 0486453391,
    LC: QA299.3.D28.

  Parameters:

    Input, int ORDER, the order of the rule.
    1 <= ORDER.

    Output, double X[ORDER], the abscissas.
*/
{
  int i;
  double pi = 3.141592653589793;

  if ( order < 1 )
  {
    printf ( "\n" );
    printf ( "CHEBYSHEV1_COMPUTE_POINTS - Fatal error!\n" );
    printf ( "  Illegal value of ORDER = %d\n", order );
    exit ( 1 );
  }

__global__ void _AFFINE_KERNEL_3(double* ,int ,int ,int ,int );


	#ifdef DATASET
		char* outfile = (char*)malloc(sizeof(char)*(strlen(readfile)+50));
		strcpy(outfile, readfile);
		strcat(outfile, ".data");
		FILE* fp;
		fp = fopen(outfile, "a");
	#endif

	#ifdef TIME
		struct timespec start_3, end_3, mid_start_3, mid_end_3;
		double runTime_3, pre_time_3, post_time_3, computeTime_3;
	#endif
	double _SZ_x_3 = 1;

	#ifdef TIME
		clock_gettime(CLOCK_MONOTONIC, &start_3);
	#endif

	// ----------Allocating memory to Kernel Variable and copying them on device----------
	double *_DEV_x_3;
	cudaMalloc((void**) &_DEV_x_3,sizeof(double) *_SZ_x_3);
	cudaMemcpy(_DEV_x_3,x,sizeof(double)*_SZ_x_3, cudaMemcpyHostToDevice);
	int _NUM_THREADS_3= 1;
	float _NUM_BLOCKS_3=1;
	int _NUM_TILE_3=1;
	dim3 _THREADS_3(512);
	dim3 _BLOCKS_3(1);
	if(_NUM_THREADS_3 < _NTHREAD)
	{
		_THREADS_3.x=_NUM_THREADS_3;
	}
	else {
		 _THREADS_3.x=_NTHREAD;
		_NUM_BLOCKS_3=(_NUM_THREADS_3 % _NTHREAD == 0)?(_NUM_THREADS_3/_NTHREAD):((_NUM_THREADS_3/_NTHREAD)+1);
		if(_NUM_BLOCKS_3<_NBLOCK)
			_BLOCKS_3.x=_NUM_BLOCKS_3;
		else {
			_BLOCKS_3.x=_NBLOCK;
			int temp_3=_NUM_BLOCKS_3;
			_NUM_TILE_3=(temp_3 % _NBLOCK == 0)?(_NUM_BLOCKS_3/_NBLOCK):((_NUM_BLOCKS_3/_NBLOCK)+1);
		}
	}

	#ifdef TIME
		clock_gettime(CLOCK_MONOTONIC, &mid_start_3);
	#endif

	int _CUDA_TILE_3;
	for(_CUDA_TILE_3=0;_CUDA_TILE_3<_NUM_TILE_3;_CUDA_TILE_3++)
	{
		_AFFINE_KERNEL_3<<<_BLOCKS_3,_THREADS_3>>>( _DEV_x_3, _SZ_x_3,0,9, _CUDA_TILE_3);
		cudaDeviceSynchronize();
	}

	#ifdef TIME
		clock_gettime(CLOCK_MONOTONIC, &mid_end_3);
	#endif
	cudaMemcpy(x, _DEV_x_3,sizeof(double) *_SZ_x_3, cudaMemcpyDeviceToHost);
	cudaFree(_DEV_x_3);

	#ifdef TIME
		clock_gettime(CLOCK_MONOTONIC, &end_3);

		pre_time_3 = (double) ((((&mid_start_3)->tv_sec * 1000000000) + (&mid_start_3)->tv_nsec) - (((&start_3)->tv_sec * 1000000000) + (&start_3)->tv_nsec)) / 1000000000;
		post_time_3 = (double) ((((&end_3)->tv_sec * 1000000000) + (&end_3)->tv_nsec) - (((&mid_end_3)->tv_sec * 1000000000) + (&mid_end_3)->tv_nsec)) / 1000000000;
		computeTime_3 = (double) ((((&mid_end_3)->tv_sec * 1000000000) + (&mid_end_3)->tv_nsec) - (((&mid_start_3)->tv_sec * 1000000000) + (&mid_start_3)->tv_nsec)) / 1000000000;
		runTime_3 = (double) ((((&end_3)->tv_sec * 1000000000) + (&end_3)->tv_nsec) - (((&start_3)->tv_sec * 1000000000) + (&start_3)->tv_nsec)) / 1000000000;
	#endif

	#ifdef DATASET
		fprintf(fp,"%%d,%%d,%%d,%%d,%%d,%%.14f,%%.14f,%%.14f,%%.14f,%%d\n",N,_NTHREAD*_NBLOCK,_THREADS_3.x,_BLOCKS_3.x,data,pre_time_3,computeTime_3,post_time_3,runTime_3,_CUDA_TILE_3);
		fclose(fp);
		fclose(f);
	#else
	#ifdef TIME
		printf("Runtime:%%f\n",runTime_3);
	#endif
	#endif
  if ( ( order % 2 ) == 1 )
  {
    x[(order-1)/2] = 0.0;
  }

  return;
}
/******************************************************************************/
void chebyshev1_compute_points_np ( int order, int np, double p[], double x[] )

/******************************************************************************/
/*
  Purpose:

    CHEBYSHEV1_COMPUTE_POINTS_NP computes Chebyshev type 1 quadrature points.

  Licensing:

    This code is distributed under the GNU LGPL license. 

  Modified:

    16 November 2009

  Author:

    John Burkardt

  Reference:

    Philip Davis, Philip Rabinowitz,
    Methods of Numerical Integration,
    Second Edition,
    Dover, 2007,
    ISBN: 0486453391,
    LC: QA299.3.D28.

  Parameters:

    Input, int ORDER, the order of the rule.
    1 <= ORDER.

    Input, int NP, the number of parameters.

    Input, double P[NP], parameters which are not needed by this function.

    Output, double X[ORDER], the abscissas.
*/
{
  chebyshev1_compute_points ( order, x );

  return;
}
/******************************************************************************/
void chebyshev1_compute_weights ( int order, double w[] )

/******************************************************************************/
/*
  Purpose:

    CHEBYSHEV1_COMPUTE_WEIGHTS computes Chebyshev type 1 quadrature weights.

  Licensing:

    This code is distributed under the GNU LGPL license. 

  Modified:

    16 November 2009

  Author:

    John Burkardt

  Reference:

    Philip Davis, Philip Rabinowitz,
    Methods of Numerical Integration,
    Second Edition,
    Dover, 2007,
    ISBN: 0486453391,
    LC: QA299.3.D28.

  Parameters:

    Input, int ORDER, the order of the rule.
    1 <= ORDER.
*/
{
  int i;
  double pi = 3.141592653589793;

  if ( order < 1 )
  {
    printf ( "\n" );
    printf ( "CHEBYSHEV1_COMPUTE_WEIGHTS - Fatal error!\n" );
    printf ( "  Illegal value of ORDER = %d\n", order );
    exit ( 1 );
  }

__global__ void _AFFINE_KERNEL_4(double* ,int ,int ,int ,int );


	#ifdef DATASET
		char* outfile = (char*)malloc(sizeof(char)*(strlen(readfile)+50));
		strcpy(outfile, readfile);
		strcat(outfile, ".data");
		FILE* fp;
		fp = fopen(outfile, "a");
	#endif

	#ifdef TIME
		struct timespec start_4, end_4, mid_start_4, mid_end_4;
		double runTime_4, pre_time_4, post_time_4, computeTime_4;
	#endif
	double _SZ_w_4 = 1;

	#ifdef TIME
		clock_gettime(CLOCK_MONOTONIC, &start_4);
	#endif

	// ----------Allocating memory to Kernel Variable and copying them on device----------
	double *_DEV_w_4;
	cudaMalloc((void**) &_DEV_w_4,sizeof(double) *_SZ_w_4);
	cudaMemcpy(_DEV_w_4,w,sizeof(double)*_SZ_w_4, cudaMemcpyHostToDevice);
	int _NUM_THREADS_4= 1;
	float _NUM_BLOCKS_4=1;
	int _NUM_TILE_4=1;
	dim3 _THREADS_4(512);
	dim3 _BLOCKS_4(1);
	if(_NUM_THREADS_4 < _NTHREAD)
	{
		_THREADS_4.x=_NUM_THREADS_4;
	}
	else {
		 _THREADS_4.x=_NTHREAD;
		_NUM_BLOCKS_4=(_NUM_THREADS_4 % _NTHREAD == 0)?(_NUM_THREADS_4/_NTHREAD):((_NUM_THREADS_4/_NTHREAD)+1);
		if(_NUM_BLOCKS_4<_NBLOCK)
			_BLOCKS_4.x=_NUM_BLOCKS_4;
		else {
			_BLOCKS_4.x=_NBLOCK;
			int temp_4=_NUM_BLOCKS_4;
			_NUM_TILE_4=(temp_4 % _NBLOCK == 0)?(_NUM_BLOCKS_4/_NBLOCK):((_NUM_BLOCKS_4/_NBLOCK)+1);
		}
	}

	#ifdef TIME
		clock_gettime(CLOCK_MONOTONIC, &mid_start_4);
	#endif

	int _CUDA_TILE_4;
	for(_CUDA_TILE_4=0;_CUDA_TILE_4<_NUM_TILE_4;_CUDA_TILE_4++)
	{
		_AFFINE_KERNEL_4<<<_BLOCKS_4,_THREADS_4>>>( _DEV_w_4, _SZ_w_4,0,9, _CUDA_TILE_4);
		cudaDeviceSynchronize();
	}

	#ifdef TIME
		clock_gettime(CLOCK_MONOTONIC, &mid_end_4);
	#endif
	cudaMemcpy(w, _DEV_w_4,sizeof(double) *_SZ_w_4, cudaMemcpyDeviceToHost);
	cudaFree(_DEV_w_4);

	#ifdef TIME
		clock_gettime(CLOCK_MONOTONIC, &end_4);

		pre_time_4 = (double) ((((&mid_start_4)->tv_sec * 1000000000) + (&mid_start_4)->tv_nsec) - (((&start_4)->tv_sec * 1000000000) + (&start_4)->tv_nsec)) / 1000000000;
		post_time_4 = (double) ((((&end_4)->tv_sec * 1000000000) + (&end_4)->tv_nsec) - (((&mid_end_4)->tv_sec * 1000000000) + (&mid_end_4)->tv_nsec)) / 1000000000;
		computeTime_4 = (double) ((((&mid_end_4)->tv_sec * 1000000000) + (&mid_end_4)->tv_nsec) - (((&mid_start_4)->tv_sec * 1000000000) + (&mid_start_4)->tv_nsec)) / 1000000000;
		runTime_4 = (double) ((((&end_4)->tv_sec * 1000000000) + (&end_4)->tv_nsec) - (((&start_4)->tv_sec * 1000000000) + (&start_4)->tv_nsec)) / 1000000000;
	#endif

	#ifdef DATASET
		fprintf(fp,"%%d,%%d,%%d,%%d,%%d,%%.14f,%%.14f,%%.14f,%%.14f,%%d\n",N,_NTHREAD*_NBLOCK,_THREADS_4.x,_BLOCKS_4.x,data,pre_time_4,computeTime_4,post_time_4,runTime_4,_CUDA_TILE_4);
		fclose(fp);
		fclose(f);
	#else
	#ifdef TIME
		printf("Runtime:%%f\n",runTime_4);
	#endif
	#endif

  return;
}
/******************************************************************************/

void chebyshev1_compute_weights_np ( int order, int np, double p[], double w[] )

/******************************************************************************/
/*
  Purpose:

    CHEBYSHEV1_COMPUTE_WEIGHTS_NP: Chebyshev type 1 quadrature weights.

  Licensing:

    This code is distributed under the GNU LGPL license. 

  Modified:

    16 November 2009

  Author:

    John Burkardt

  Reference:

    Philip Davis, Philip Rabinowitz,
    Methods of Numerical Integration,
    Second Edition,
    Dover, 2007,
    ISBN: 0486453391,
    LC: QA299.3.D28.

  Parameters:

    Input, int ORDER, the order of the rule.
    1 <= ORDER.

    Input, int NP, the number of parameters.

    Input, double P[NP], parameters which are not needed by this function.

    Output, double W[ORDER], the weights.
*/
{
  chebyshev1_compute_weights ( order, w );

  return;
}
/******************************************************************************/


/******************************************************************************/
void chebyshev2_compute ( int order, double x[], double w[] )

/******************************************************************************/
/*
  Purpose:

    CHEBYSHEV2_COMPUTE computes a Chebyshev type 2 quadrature rule.

  Discussion:

    The integration interval is [ -1, 1 ].

    The weight function is w(x) = sqrt ( 1 - x^2 ).

    The integral to approximate:

      Integral ( -1 <= X <= 1 ) F(X)  sqrt ( 1 - x^2 )  dX

    The quadrature rule:

      Sum ( 1 <= I <= ORDER ) W(I) * F ( X(I) )

  Licensing:

    This code is distributed under the GNU LGPL license. 

  Modified:

    16 November 2009

  Author:

    John Burkardt

  Reference:

    Philip Davis, Philip Rabinowitz,
    Methods of Numerical Integration,
    Second Edition,
    Dover, 2007,
    ISBN: 0486453391,
    LC: QA299.3.D28.

  Parameters:

    Input, int ORDER, the order of the rule.
    1 <= ORDER.

    Output, double X[ORDER], the abscissas.

    Output, double W[ORDER], the weights.
*/
{
  double angle;
  int i;
  double pi = 3.141592653589793;

  if ( order < 1 )
  {
    printf ( "\n" );
    printf ( "CHEBYSHEV2_COMPUTE - Fatal error!\n" );
    printf ( "  Illegal value of ORDER = %d\n", order );
    exit ( 1 );
  }

__global__ void _AFFINE_KERNEL_5(double* ,int ,double* ,int ,int ,int ,int );


	#ifdef DATASET
		char* outfile = (char*)malloc(sizeof(char)*(strlen(readfile)+50));
		strcpy(outfile, readfile);
		strcat(outfile, ".data");
		FILE* fp;
		fp = fopen(outfile, "a");
	#endif

	#ifdef TIME
		struct timespec start_5, end_5, mid_start_5, mid_end_5;
		double runTime_5, pre_time_5, post_time_5, computeTime_5;
	#endif
	double _SZ_w_5 = 1;
	double _SZ_x_5 = 1;

	#ifdef TIME
		clock_gettime(CLOCK_MONOTONIC, &start_5);
	#endif

	// ----------Allocating memory to Kernel Variable and copying them on device----------
	double *_DEV_w_5;
	cudaMalloc((void**) &_DEV_w_5,sizeof(double) *_SZ_w_5);
	cudaMemcpy(_DEV_w_5,w,sizeof(double)*_SZ_w_5, cudaMemcpyHostToDevice);
	double *_DEV_x_5;
	cudaMalloc((void**) &_DEV_x_5,sizeof(double) *_SZ_x_5);
	cudaMemcpy(_DEV_x_5,x,sizeof(double)*_SZ_x_5, cudaMemcpyHostToDevice);
	int _NUM_THREADS_5= 1;
	float _NUM_BLOCKS_5=1;
	int _NUM_TILE_5=1;
	dim3 _THREADS_5(512);
	dim3 _BLOCKS_5(1);
	if(_NUM_THREADS_5 < _NTHREAD)
	{
		_THREADS_5.x=_NUM_THREADS_5;
	}
	else {
		 _THREADS_5.x=_NTHREAD;
		_NUM_BLOCKS_5=(_NUM_THREADS_5 % _NTHREAD == 0)?(_NUM_THREADS_5/_NTHREAD):((_NUM_THREADS_5/_NTHREAD)+1);
		if(_NUM_BLOCKS_5<_NBLOCK)
			_BLOCKS_5.x=_NUM_BLOCKS_5;
		else {
			_BLOCKS_5.x=_NBLOCK;
			int temp_5=_NUM_BLOCKS_5;
			_NUM_TILE_5=(temp_5 % _NBLOCK == 0)?(_NUM_BLOCKS_5/_NBLOCK):((_NUM_BLOCKS_5/_NBLOCK)+1);
		}
	}

	#ifdef TIME
		clock_gettime(CLOCK_MONOTONIC, &mid_start_5);
	#endif

	int _CUDA_TILE_5;
	for(_CUDA_TILE_5=0;_CUDA_TILE_5<_NUM_TILE_5;_CUDA_TILE_5++)
	{
		_AFFINE_KERNEL_5<<<_BLOCKS_5,_THREADS_5>>>( _DEV_w_5, _SZ_w_5, _DEV_x_5, _SZ_x_5,0,9, _CUDA_TILE_5);
		cudaDeviceSynchronize();
	}

	#ifdef TIME
		clock_gettime(CLOCK_MONOTONIC, &mid_end_5);
	#endif
	cudaMemcpy(w, _DEV_w_5,sizeof(double) *_SZ_w_5, cudaMemcpyDeviceToHost);
	cudaMemcpy(x, _DEV_x_5,sizeof(double) *_SZ_x_5, cudaMemcpyDeviceToHost);
	cudaFree(_DEV_w_5);
	cudaFree(_DEV_x_5);

	#ifdef TIME
		clock_gettime(CLOCK_MONOTONIC, &end_5);

		pre_time_5 = (double) ((((&mid_start_5)->tv_sec * 1000000000) + (&mid_start_5)->tv_nsec) - (((&start_5)->tv_sec * 1000000000) + (&start_5)->tv_nsec)) / 1000000000;
		post_time_5 = (double) ((((&end_5)->tv_sec * 1000000000) + (&end_5)->tv_nsec) - (((&mid_end_5)->tv_sec * 1000000000) + (&mid_end_5)->tv_nsec)) / 1000000000;
		computeTime_5 = (double) ((((&mid_end_5)->tv_sec * 1000000000) + (&mid_end_5)->tv_nsec) - (((&mid_start_5)->tv_sec * 1000000000) + (&mid_start_5)->tv_nsec)) / 1000000000;
		runTime_5 = (double) ((((&end_5)->tv_sec * 1000000000) + (&end_5)->tv_nsec) - (((&start_5)->tv_sec * 1000000000) + (&start_5)->tv_nsec)) / 1000000000;
	#endif

	#ifdef DATASET
		fprintf(fp,"%%d,%%d,%%d,%%d,%%d,%%.14f,%%.14f,%%.14f,%%.14f,%%d\n",N,_NTHREAD*_NBLOCK,_THREADS_5.x,_BLOCKS_5.x,data,pre_time_5,computeTime_5,post_time_5,runTime_5,_CUDA_TILE_5);
		fclose(fp);
		fclose(f);
	#else
	#ifdef TIME
		printf("Runtime:%%f\n",runTime_5);
	#endif
	#endif

  if ( ( order % 2 ) == 1 )
  {
    x[(order-1)/2] = 0.0;
  }

  return;
}
/******************************************************************************/

void chebyshev2_compute_np ( int order, int np, double p[], double x[], 
  double w[] )

/******************************************************************************/
/*
  Purpose:

    CHEBYSHEV2_COMPUTE_NP computes a Chebyshev type 2 quadrature rule.

  Discussion:

    The integration interval is [ -1, 1 ].

    The weight function is w(x) = sqrt ( 1 - x^2 ).

    The integral to approximate:

      Integral ( -1 <= X <= 1 ) F(X)  sqrt ( 1 - x^2 )  dX

    The quadrature rule:

      Sum ( 1 <= I <= ORDER ) W(I) * F ( X(I) )

  Licensing:

    This code is distributed under the GNU LGPL license. 

  Modified:

    16 November 2009

  Author:

    John Burkardt

  Reference:

    Philip Davis, Philip Rabinowitz,
    Methods of Numerical Integration,
    Second Edition,
    Dover, 2007,
    ISBN: 0486453391,
    LC: QA299.3.D28.

  Parameters:

    Input, int ORDER, the order of the rule.
    1 <= ORDER.

    Input, int NP, the number of parameters.

    Input, double P[NP], parameters which are not needed by this function.

    Output, double X[ORDER], the abscissas.

    Output, double W[ORDER], the weights.
*/
{
  chebyshev2_compute ( order, x, w );

  return;
}
/******************************************************************************/


/******************************************************************************/

void chebyshev2_compute_points_np ( int order, int np, double p[], double x[] )

/******************************************************************************/
/*
  Purpose:

    CHEBYSHEV2_COMPUTE_POINTS_NP computes Chebyshev type 2 quadrature points.

  Licensing:

    This code is distributed under the GNU LGPL license. 

  Modified:

    16 November 2009

  Author:

    John Burkardt

  Reference:

    Philip Davis, Philip Rabinowitz,
    Methods of Numerical Integration,
    Second Edition,
    Dover, 2007,
    ISBN: 0486453391,
    LC: QA299.3.D28.

  Parameters:

    Input, int ORDER, the order of the rule.
    1 <= ORDER.

    Input, int NP, the number of parameters.

    Input, double P[NP], parameters which are not needed by this function.

    Output, double X[ORDER], the abscissas.
*/
{
  chebyshev2_compute_points ( order, x );

  return;
}
/******************************************************************************/
void chebyshev2_compute_points ( int order, double x[] )

/******************************************************************************/
/*
  Purpose:

    CHEBYSHEV2_COMPUTE_POINTS computes Chebyshev type 2 quadrature points.

  Licensing:

    This code is distributed under the GNU LGPL license. 

  Modified:

    16 November 2009

  Author:

    John Burkardt

  Reference:

    Philip Davis, Philip Rabinowitz,
    Methods of Numerical Integration,
    Second Edition,
    Dover, 2007,
    ISBN: 0486453391,
    LC: QA299.3.D28.

  Parameters:

    Input, int ORDER, the order of the rule.
    1 <= ORDER.

    Output, double X[ORDER], the abscissas.
*/
{
  double angle;
  int i;
  double pi = 3.141592653589793;

  if ( order < 1 )
  {
    printf ( "\n" );
    printf ( "CHEBYSHEV2_COMPUTE_POINTS - Fatal error!\n" );
    printf ( "  Illegal value of ORDER = %d\n", order );
    exit ( 1 );
  }

__global__ void _AFFINE_KERNEL_6(double* ,int ,int ,int ,int );


	#ifdef DATASET
		char* outfile = (char*)malloc(sizeof(char)*(strlen(readfile)+50));
		strcpy(outfile, readfile);
		strcat(outfile, ".data");
		FILE* fp;
		fp = fopen(outfile, "a");
	#endif

	#ifdef TIME
		struct timespec start_6, end_6, mid_start_6, mid_end_6;
		double runTime_6, pre_time_6, post_time_6, computeTime_6;
	#endif
	double _SZ_x_6 = 1;

	#ifdef TIME
		clock_gettime(CLOCK_MONOTONIC, &start_6);
	#endif

	// ----------Allocating memory to Kernel Variable and copying them on device----------
	double *_DEV_x_6;
	cudaMalloc((void**) &_DEV_x_6,sizeof(double) *_SZ_x_6);
	cudaMemcpy(_DEV_x_6,x,sizeof(double)*_SZ_x_6, cudaMemcpyHostToDevice);
	int _NUM_THREADS_6= 1;
	float _NUM_BLOCKS_6=1;
	int _NUM_TILE_6=1;
	dim3 _THREADS_6(512);
	dim3 _BLOCKS_6(1);
	if(_NUM_THREADS_6 < _NTHREAD)
	{
		_THREADS_6.x=_NUM_THREADS_6;
	}
	else {
		 _THREADS_6.x=_NTHREAD;
		_NUM_BLOCKS_6=(_NUM_THREADS_6 % _NTHREAD == 0)?(_NUM_THREADS_6/_NTHREAD):((_NUM_THREADS_6/_NTHREAD)+1);
		if(_NUM_BLOCKS_6<_NBLOCK)
			_BLOCKS_6.x=_NUM_BLOCKS_6;
		else {
			_BLOCKS_6.x=_NBLOCK;
			int temp_6=_NUM_BLOCKS_6;
			_NUM_TILE_6=(temp_6 % _NBLOCK == 0)?(_NUM_BLOCKS_6/_NBLOCK):((_NUM_BLOCKS_6/_NBLOCK)+1);
		}
	}

	#ifdef TIME
		clock_gettime(CLOCK_MONOTONIC, &mid_start_6);
	#endif

	int _CUDA_TILE_6;
	for(_CUDA_TILE_6=0;_CUDA_TILE_6<_NUM_TILE_6;_CUDA_TILE_6++)
	{
		_AFFINE_KERNEL_6<<<_BLOCKS_6,_THREADS_6>>>( _DEV_x_6, _SZ_x_6,0,9, _CUDA_TILE_6);
		cudaDeviceSynchronize();
	}

	#ifdef TIME
		clock_gettime(CLOCK_MONOTONIC, &mid_end_6);
	#endif
	cudaMemcpy(x, _DEV_x_6,sizeof(double) *_SZ_x_6, cudaMemcpyDeviceToHost);
	cudaFree(_DEV_x_6);

	#ifdef TIME
		clock_gettime(CLOCK_MONOTONIC, &end_6);

		pre_time_6 = (double) ((((&mid_start_6)->tv_sec * 1000000000) + (&mid_start_6)->tv_nsec) - (((&start_6)->tv_sec * 1000000000) + (&start_6)->tv_nsec)) / 1000000000;
		post_time_6 = (double) ((((&end_6)->tv_sec * 1000000000) + (&end_6)->tv_nsec) - (((&mid_end_6)->tv_sec * 1000000000) + (&mid_end_6)->tv_nsec)) / 1000000000;
		computeTime_6 = (double) ((((&mid_end_6)->tv_sec * 1000000000) + (&mid_end_6)->tv_nsec) - (((&mid_start_6)->tv_sec * 1000000000) + (&mid_start_6)->tv_nsec)) / 1000000000;
		runTime_6 = (double) ((((&end_6)->tv_sec * 1000000000) + (&end_6)->tv_nsec) - (((&start_6)->tv_sec * 1000000000) + (&start_6)->tv_nsec)) / 1000000000;
	#endif

	#ifdef DATASET
		fprintf(fp,"%%d,%%d,%%d,%%d,%%d,%%.14f,%%.14f,%%.14f,%%.14f,%%d\n",N,_NTHREAD*_NBLOCK,_THREADS_6.x,_BLOCKS_6.x,data,pre_time_6,computeTime_6,post_time_6,runTime_6,_CUDA_TILE_6);
		fclose(fp);
		fclose(f);
	#else
	#ifdef TIME
		printf("Runtime:%%f\n",runTime_6);
	#endif
	#endif

  if ( ( order % 2 ) == 1 )
  {
    x[(order-1)/2] = 0.0;
  }

  return;
}
void chebyshev2_compute_weights ( int order, double w[] )

/******************************************************************************/
/*
  Purpose:

    CHEBYSHEV2_COMPUTE_WEIGHTS computes Chebyshev type 2 quadrature weights.

  Licensing:

    This code is distributed under the GNU LGPL license. 

  Modified:

    16 November 2009

  Author:

    John Burkardt

  Reference:

    Philip Davis, Philip Rabinowitz,
    Methods of Numerical Integration,
    Second Edition,
    Dover, 2007,
    ISBN: 0486453391,
    LC: QA299.3.D28.

  Parameters:

    Input, int ORDER, the order of the rule.
    1 <= ORDER.

    Output, double W[ORDER], the weights.
*/
{
  double angle;
  int i;
  double pi = 3.141592653589793;

  if ( order < 1 )
  {
    printf ( "\n" );
    printf ( "CHEBYSHEV2_COMPUTE_WEIGHTS - Fatal error!\n" );
    printf ( "  Illegal value of ORDER = %d\n", order );
    exit ( 1 );
  }

__global__ void _AFFINE_KERNEL_7(double* ,int ,int ,int ,int );


	#ifdef DATASET
		char* outfile = (char*)malloc(sizeof(char)*(strlen(readfile)+50));
		strcpy(outfile, readfile);
		strcat(outfile, ".data");
		FILE* fp;
		fp = fopen(outfile, "a");
	#endif

	#ifdef TIME
		struct timespec start_7, end_7, mid_start_7, mid_end_7;
		double runTime_7, pre_time_7, post_time_7, computeTime_7;
	#endif
	double _SZ_w_7 = 1;

	#ifdef TIME
		clock_gettime(CLOCK_MONOTONIC, &start_7);
	#endif

	// ----------Allocating memory to Kernel Variable and copying them on device----------
	double *_DEV_w_7;
	cudaMalloc((void**) &_DEV_w_7,sizeof(double) *_SZ_w_7);
	cudaMemcpy(_DEV_w_7,w,sizeof(double)*_SZ_w_7, cudaMemcpyHostToDevice);
	int _NUM_THREADS_7= 1;
	float _NUM_BLOCKS_7=1;
	int _NUM_TILE_7=1;
	dim3 _THREADS_7(512);
	dim3 _BLOCKS_7(1);
	if(_NUM_THREADS_7 < _NTHREAD)
	{
		_THREADS_7.x=_NUM_THREADS_7;
	}
	else {
		 _THREADS_7.x=_NTHREAD;
		_NUM_BLOCKS_7=(_NUM_THREADS_7 % _NTHREAD == 0)?(_NUM_THREADS_7/_NTHREAD):((_NUM_THREADS_7/_NTHREAD)+1);
		if(_NUM_BLOCKS_7<_NBLOCK)
			_BLOCKS_7.x=_NUM_BLOCKS_7;
		else {
			_BLOCKS_7.x=_NBLOCK;
			int temp_7=_NUM_BLOCKS_7;
			_NUM_TILE_7=(temp_7 % _NBLOCK == 0)?(_NUM_BLOCKS_7/_NBLOCK):((_NUM_BLOCKS_7/_NBLOCK)+1);
		}
	}

	#ifdef TIME
		clock_gettime(CLOCK_MONOTONIC, &mid_start_7);
	#endif

	int _CUDA_TILE_7;
	for(_CUDA_TILE_7=0;_CUDA_TILE_7<_NUM_TILE_7;_CUDA_TILE_7++)
	{
		_AFFINE_KERNEL_7<<<_BLOCKS_7,_THREADS_7>>>( _DEV_w_7, _SZ_w_7,0,9, _CUDA_TILE_7);
		cudaDeviceSynchronize();
	}

	#ifdef TIME
		clock_gettime(CLOCK_MONOTONIC, &mid_end_7);
	#endif
	cudaMemcpy(w, _DEV_w_7,sizeof(double) *_SZ_w_7, cudaMemcpyDeviceToHost);
	cudaFree(_DEV_w_7);

	#ifdef TIME
		clock_gettime(CLOCK_MONOTONIC, &end_7);

		pre_time_7 = (double) ((((&mid_start_7)->tv_sec * 1000000000) + (&mid_start_7)->tv_nsec) - (((&start_7)->tv_sec * 1000000000) + (&start_7)->tv_nsec)) / 1000000000;
		post_time_7 = (double) ((((&end_7)->tv_sec * 1000000000) + (&end_7)->tv_nsec) - (((&mid_end_7)->tv_sec * 1000000000) + (&mid_end_7)->tv_nsec)) / 1000000000;
		computeTime_7 = (double) ((((&mid_end_7)->tv_sec * 1000000000) + (&mid_end_7)->tv_nsec) - (((&mid_start_7)->tv_sec * 1000000000) + (&mid_start_7)->tv_nsec)) / 1000000000;
		runTime_7 = (double) ((((&end_7)->tv_sec * 1000000000) + (&end_7)->tv_nsec) - (((&start_7)->tv_sec * 1000000000) + (&start_7)->tv_nsec)) / 1000000000;
	#endif

	#ifdef DATASET
		fprintf(fp,"%%d,%%d,%%d,%%d,%%d,%%.14f,%%.14f,%%.14f,%%.14f,%%d\n",N,_NTHREAD*_NBLOCK,_THREADS_7.x,_BLOCKS_7.x,data,pre_time_7,computeTime_7,post_time_7,runTime_7,_CUDA_TILE_7);
		fclose(fp);
		fclose(f);
	#else
	#ifdef TIME
		printf("Runtime:%%f\n",runTime_7);
	#endif
	#endif

  return;
}




__global__ void _AFFINE_KERNEL_0(int* bvec,int  _SZ_bvec_0,int CUDA_L_i,int CUDA_U_i,int _CUDA_TILE)
{
	int i = gridDim.x*blockDim.x*_CUDA_TILE + blockDim.x*blockIdx.x + threadIdx.x;
	if((CUDA_L_i<=i)&&(i<=CUDA_U_i)){
if(bvec[1+i] == 1) {bvec[1+i] = 0;}else {bvec[1+i] = 1;break;}
}}



__global__ void _AFFINE_KERNEL_1(double* w,int  _SZ_w_1,int CUDA_L_i,int CUDA_U_i,int _CUDA_TILE)
{
	int i = gridDim.x*blockDim.x*_CUDA_TILE + blockDim.x*blockIdx.x + threadIdx.x;
	if((CUDA_L_i<=i)&&(i<=CUDA_U_i)){
w[1+i] =(pi /((double )order));
}}



__global__ void _AFFINE_KERNEL_2(double* x,int  _SZ_x_2,int CUDA_L_i,int CUDA_U_i,int _CUDA_TILE)
{
	int i = gridDim.x*blockDim.x*_CUDA_TILE + blockDim.x*blockIdx.x + threadIdx.x;
	if((CUDA_L_i<=i)&&(i<=CUDA_U_i)){
x[i] = cos(((pi *((double )(((2 * order) - 1) -(2 * i)))) /((double )(2 * order))));
}}



__global__ void _AFFINE_KERNEL_3(double* x,int  _SZ_x_3,int CUDA_L_i,int CUDA_U_i,int _CUDA_TILE)
{
	int i = gridDim.x*blockDim.x*_CUDA_TILE + blockDim.x*blockIdx.x + threadIdx.x;
	if((CUDA_L_i<=i)&&(i<=CUDA_U_i)){
x[i] = cos(((pi *((double )(((2 * order) - 1) -(2 * i)))) /((double )(2 * order))));
}}



__global__ void _AFFINE_KERNEL_4(double* w,int  _SZ_w_4,int CUDA_L_i,int CUDA_U_i,int _CUDA_TILE)
{
	int i = gridDim.x*blockDim.x*_CUDA_TILE + blockDim.x*blockIdx.x + threadIdx.x;
	if((CUDA_L_i<=i)&&(i<=CUDA_U_i)){
w[1+i] =(pi /((double )order));
}}



__global__ void _AFFINE_KERNEL_5(double* w,int  _SZ_w_5,double* x,int  _SZ_x_5,int CUDA_L_i,int CUDA_U_i,int _CUDA_TILE)
{
	int i = gridDim.x*blockDim.x*_CUDA_TILE + blockDim.x*blockIdx.x + threadIdx.x;
	if((CUDA_L_i<=i)&&(i<=CUDA_U_i)){
angle =((pi *((double )(order - i))) /((double )(order + 1)));
w[i] =((pi /((double )(order + 1))) * pow(sin(angle),2));
x[i] = cos(angle);
}}



__global__ void _AFFINE_KERNEL_6(double* x,int  _SZ_x_6,int CUDA_L_i,int CUDA_U_i,int _CUDA_TILE)
{
	int i = gridDim.x*blockDim.x*_CUDA_TILE + blockDim.x*blockIdx.x + threadIdx.x;
	if((CUDA_L_i<=i)&&(i<=CUDA_U_i)){
angle =((pi *((double )(order - i))) /((double )(order + 1)));
x[i] = cos(angle);
}}



__global__ void _AFFINE_KERNEL_7(double* w,int  _SZ_w_7,int CUDA_L_i,int CUDA_U_i,int _CUDA_TILE)
{
	int i = gridDim.x*blockDim.x*_CUDA_TILE + blockDim.x*blockIdx.x + threadIdx.x;
	if((CUDA_L_i<=i)&&(i<=CUDA_U_i)){
angle =((pi *((double )(order - i))) /((double )(order + 1)));
w[i] =((pi /((double )(order + 1))) * pow(sin(angle),2));
}}


